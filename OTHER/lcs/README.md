### 优化子结构

设序列X=`<x1,…,xm>`和Y=`<y1,…,yn>`的最长公共子序列是Z=`<z1, …, zk>`
* 如果xm == yn

        zk=xm=yn
        <z1,…, zk-1>是<x1,…,xm-1>和<y1,…,yn-1>的最长公共子序列

* 如果xm != yn且zk !=xm

        <z1,…, zk>是<x1,…,xm-1>和<y1,…,yn>的最长公共子序列

* 如果xm!= yn且zk != yn

        <z1,…, zk>是<x1,…,xm>和<y1,…,yn-1>的最长公共子序列


找`<x1,…,xm>`和`<y1,…,yn>`的最长公共子序列

* 如果xm == yn

        找<x1,…,xm-1>和<y1,…,yn-1>的最长公共子序列，在其尾部加上xm

* 如果xmyn

        找<x1,…,xm-1>和<y1,…,yn>的最长公共子序列
        找<x1,…,xm>和<y1,…,yn-1>的最长公共子序列
        取这两个公共序列的较长者

### 递归式

用c(i, j)表示`<x1,…, xi>`和`<y1,…,yj>`的最长公共子序列的长度

* `i == 0 || j == 0`

        c(i,j) = 0

* `i > 0 && j > 0 && xi == yj`

        c(i,j) = c(i-1,j-1)+1

* `i < 0 && j < 0 && xi != yj`

        c(i,j) = max{c(i-1,j), c(i,j-1)}

